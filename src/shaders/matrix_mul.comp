#version 450

// Simple matrix multiplication compute shader (for debugging)
// Computes: C = A * B where A is MxK, B is KxN, C is MxN
// No tiling - direct computation for clarity and correctness

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0) buffer InputBufferA {
    float a[];
};

layout(set = 0, binding = 1) buffer InputBufferB {
    float b[];
};

layout(set = 0, binding = 2) buffer OutputBuffer {
    float result[];
};

layout(set = 0, binding = 3) uniform UniformBuffer {
    uint M;    // Rows of A, rows of C
    uint N;    // Cols of B, cols of C
    uint K;    // Cols of A, rows of B
};

void main() {
    uint row = gl_GlobalInvocationID.y;
    uint col = gl_GlobalInvocationID.x;

    // Bounds checking for output matrix
    if (row >= M || col >= N) {
        return;
    }

    // Compute C[row][col] = sum over k of A[row][k] * B[k][col]
    float sum = 0.0;

    for (uint k = 0; k < K; k++) {
        // A is stored row-major: A[row][k] = a[row * K + k]
        // B is stored row-major: B[k][col] = b[k * N + col]
        float a_val = a[row * K + k];
        float b_val = b[k * N + col];
        sum += a_val * b_val;
    }

    // Store result C[row][col] = result[row * N + col]
    result[row * N + col] = sum;
}
